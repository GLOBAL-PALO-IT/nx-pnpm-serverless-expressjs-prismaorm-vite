import { Request, Response, NextFunction } from 'express';
import {
  authenticateToken,
  optionalAuthentication,
  requireAuth,
  getCurrentUserId,
  requireOwnership,
  requirePostOwnership,
} from './auth';
import { AuthService } from '@nx-serverless/services';
import { logger } from '../libs/logger';

// Mock dependencies
jest.mock('@nx-serverless/services');
jest.mock('../libs/logger', () => ({
  logger: {
    debug: jest.fn(),
    error: jest.fn(),
    info: jest.fn(),
    warn: jest.fn(),
    http: jest.fn(),
  },
}));

describe('auth middleware', () => {
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let nextFunction: NextFunction;
  let mockAuthService: jest.Mocked<AuthService>;

  beforeEach(() => {
    mockRequest = {
      headers: {},
      params: {},
      user: undefined,
    };
    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis(),
    };
    nextFunction = jest.fn();
    jest.clearAllMocks();

    // Get the mocked AuthService
    mockAuthService = new AuthService(logger) as jest.Mocked<AuthService>;
  });

  describe('authenticateToken', () => {
    it('should return 401 when no token is provided', async () => {
      mockRequest.headers = {};

      await authenticateToken(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        error: 'Access token is required',
      });
      expect(nextFunction).not.toHaveBeenCalled();
    });

    it('should return 401 when token is invalid', async () => {
      mockRequest.headers = {
        authorization: 'Bearer invalid_token',
      };
      mockAuthService.verifyAccessToken = jest.fn().mockReturnValue(null);

      await authenticateToken(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        error: 'Invalid or expired access token',
      });
      expect(nextFunction).not.toHaveBeenCalled();
    });

    it('should return 401 when user not found', async () => {
      mockRequest.headers = {
        authorization: 'Bearer valid_token',
      };
      mockAuthService.verifyAccessToken = jest.fn().mockReturnValue({ userId: 'user-1' });
      mockAuthService.getUserById = jest.fn().mockResolvedValue(null);

      await authenticateToken(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        error: 'User not found',
      });
      expect(nextFunction).not.toHaveBeenCalled();
    });

    it('should call next when user is authenticated', async () => {
      const mockUser = {
        id: 'user-1',
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      mockRequest.headers = {
        authorization: 'Bearer valid_token',
      };
      mockAuthService.verifyAccessToken = jest.fn().mockReturnValue({ userId: 'user-1' });
      mockAuthService.getUserById = jest.fn().mockResolvedValue(mockUser);

      await authenticateToken(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(nextFunction).toHaveBeenCalled();
      expect(mockResponse.status).not.toHaveBeenCalled();
    });

    it('should handle authentication errors', async () => {
      mockRequest.headers = {
        authorization: 'Bearer valid_token',
      };
      mockAuthService.verifyAccessToken = jest.fn().mockImplementation(() => {
        throw new Error('Token verification failed');
      });

      await authenticateToken(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        error: 'Authentication failed',
      });
      expect(nextFunction).not.toHaveBeenCalled();
    });
  });

  describe('optionalAuthentication', () => {
    it('should call next without setting user when no token is provided', async () => {
      mockRequest.headers = {};

      await optionalAuthentication(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(mockRequest.user).toBeUndefined();
      expect(nextFunction).toHaveBeenCalled();
      expect(mockResponse.status).not.toHaveBeenCalled();
    });

    it('should call next without setting user when token is invalid', async () => {
      mockRequest.headers = {
        authorization: 'Bearer invalid_token',
      };
      mockAuthService.verifyAccessToken = jest.fn().mockReturnValue(null);

      await optionalAuthentication(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(mockRequest.user).toBeUndefined();
      expect(nextFunction).toHaveBeenCalled();
      expect(mockResponse.status).not.toHaveBeenCalled();
    });

    it('should call next when token is valid', async () => {
      mockRequest.headers = {
        authorization: 'Bearer valid_token',
      };
      mockAuthService.verifyAccessToken = jest.fn().mockReturnValue({ userId: 'user-1' });
      mockAuthService.getUserById = jest.fn().mockResolvedValue({
        id: 'user-1',
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      await optionalAuthentication(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(nextFunction).toHaveBeenCalled();
    });

    it('should continue without authentication on error', async () => {
      mockRequest.headers = {
        authorization: 'Bearer valid_token',
      };
      mockAuthService.verifyAccessToken = jest.fn().mockImplementation(() => {
        throw new Error('Token verification failed');
      });

      await optionalAuthentication(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(nextFunction).toHaveBeenCalled();
      expect(mockResponse.status).not.toHaveBeenCalled();
    });
  });

  describe('requireAuth', () => {
    it('should return 401 when user is not authenticated', () => {
      mockRequest.user = undefined;

      requireAuth(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        error: 'Authentication required',
      });
      expect(nextFunction).not.toHaveBeenCalled();
    });

    it('should call next when user is authenticated', () => {
      mockRequest.user = {
        id: 'user-1',
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      requireAuth(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(nextFunction).toHaveBeenCalled();
      expect(mockResponse.status).not.toHaveBeenCalled();
    });
  });

  describe('getCurrentUserId', () => {
    it('should throw error when user is not authenticated', () => {
      mockRequest.user = undefined;

      expect(() => getCurrentUserId(mockRequest as Request)).toThrow(
        'User not authenticated'
      );
    });

    it('should return user ID when user is authenticated', () => {
      mockRequest.user = {
        id: 'user-1',
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const userId = getCurrentUserId(mockRequest as Request);

      expect(userId).toBe('user-1');
    });
  });

  describe('requireOwnership', () => {
    it('should return 401 when user is not authenticated', () => {
      mockRequest.user = undefined;
      mockRequest.params = { id: 'user-1' };

      const middleware = requireOwnership();
      middleware(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        error: 'Authentication required',
      });
      expect(nextFunction).not.toHaveBeenCalled();
    });

    it('should return 403 when user does not own the resource', () => {
      mockRequest.user = {
        id: 'user-1',
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      mockRequest.params = { id: 'user-2' };

      const middleware = requireOwnership();
      middleware(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(mockResponse.status).toHaveBeenCalledWith(403);
      expect(mockResponse.json).toHaveBeenCalledWith({
        error: 'Access denied: You can only access your own resources',
      });
      expect(nextFunction).not.toHaveBeenCalled();
    });

    it('should call next when user owns the resource', () => {
      mockRequest.user = {
        id: 'user-1',
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      mockRequest.params = { id: 'user-1' };

      const middleware = requireOwnership();
      middleware(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(nextFunction).toHaveBeenCalled();
      expect(mockResponse.status).not.toHaveBeenCalled();
    });

    it('should use custom param name', () => {
      mockRequest.user = {
        id: 'user-1',
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      mockRequest.params = { userId: 'user-1' };

      const middleware = requireOwnership('userId');
      middleware(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(nextFunction).toHaveBeenCalled();
      expect(mockResponse.status).not.toHaveBeenCalled();
    });
  });

  describe('requirePostOwnership', () => {
    it('should return 401 when user is not authenticated', async () => {
      mockRequest.user = undefined;
      mockRequest.params = { id: 'post-1' };

      await requirePostOwnership(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(mockResponse.status).toHaveBeenCalledWith(401);
      expect(mockResponse.json).toHaveBeenCalledWith({
        error: 'Authentication required',
      });
      expect(nextFunction).not.toHaveBeenCalled();
    });

    it('should return 400 when post ID is missing', async () => {
      mockRequest.user = {
        id: 'user-1',
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      mockRequest.params = {};

      await requirePostOwnership(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith({
        error: 'Post ID is required',
      });
      expect(nextFunction).not.toHaveBeenCalled();
    });

    it('should call next when post ID is provided', async () => {
      mockRequest.user = {
        id: 'user-1',
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      mockRequest.params = { id: 'post-1' };

      await requirePostOwnership(
        mockRequest as Request,
        mockResponse as Response,
        nextFunction
      );

      expect(nextFunction).toHaveBeenCalled();
      expect(mockResponse.status).not.toHaveBeenCalled();
    });

    it('should handle errors', async () => {
      mockRequest.user = {
        id: 'user-1',
        email: 'test@example.com',
        name: 'Test User',
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      mockRequest.params = { id: 'post-1' };
      
      // Force an error
      const error = new Error('Test error');
      nextFunction = jest.fn().mockImplementation(() => {
        throw error;
      });

      try {
        await requirePostOwnership(
          mockRequest as Request,
          mockResponse as Response,
          nextFunction
        );
      } catch (e) {
        // Expected to throw
      }

      expect(nextFunction).toHaveBeenCalled();
    });
  });
});
